ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :memo:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

= Диагностическая работа
:source-highlighter: rouge
:rouge-style: github
:icons: font
:sectnums:

Тут будет разбор заданий диагностической работы: приведены идеи решений, разобраны типичные ошибки.
Материала довольно много, поэтому не обязательно вычитать и понять всё сразу.
Но я ожидаю, что простые решения вы прочитаете и поймёте.
А если не поймёте, то зададите вопросы.
Ну и вернуться к этому материалу, когда попрокачаетесь никто не запрещает.

Примеры кода будут в основном на C, начинайте потихоньку его постигать.
Я постарался расписать некоторые специфические моменты.
На занятиях мы подробно всё это подробно разберём, но что-то попытаться понять можно уже сейчас.

== Задание 1

Какое наименьшее количество операции умножения достаточно для вычисления значения выражения stem:[x^4 + x^3 + x^2 + x + 1]?

=== Решение

Для начала отметим, что меньше двух операций умножения получить не получится из-за stem:[x^3 = x^2 * x = (x * x) * x] (2 умножения).

Также есть проблема с stem:[x^4 = x^2 * x^2 = (x * x) * (x * x)] (3 умножения).

Но мы же программисты и умеем сохранять результаты промежуточных вычислений!
Давайте сохраним результат одного умножения stem:[x^2 = x * x] и переиспользуем его!

Также отметим, что часть выражения вообще не требует операций умножения: stem:[x + 1].

Преобразуем формулу: stem:[x^4 + x^3 + x^2 + x + 1 = x^2 * (x^2 + x + 1) + x + 1].
Если stem:[x^2] переиспользовать, то получается 2 умножения.

Аналогичного результата можно добиться преобразованием stem:[x^4 + x^3 + x^2 + x + 1 = (x^2 + x) * (x^2 + 1) + 1].

== Задание 2

Укажите условия, при которых выражения “a + a – a” и “a + (a – a)” не эквивалентны.

=== Решение

Тут достаточно большой простор для фантазии.

[upperroman]
. В случае использования https://en.wikipedia.org/wiki/Saturation_arithmetic[арифметики с насыщением].
. Похожего поведения можно добиться при использовании чисел с плавающей запятой (например, если `a` -- очень большое число)

[source,c]
----
#include <stdio.h>

int main() {
	float a = 3.40282347e+38F;
	printf("a + a - a   = %f\n", a + a - a);
	printf("a + (a - a) = %f\n", a + (a - a));
	return 0;
}
----

Получим

----
a + a - a   = inf
a + (a - a) = 340282346638528859811704183484516925440.000000
----

[upperroman,start=3]
. Во многих языках программирования можно переопределять операторы.
Например, для множеств в Kotlin можно получить подобное поведение.

[source,kotlin]
----
fun main() {
    val a = setOf('a')
    println(a + a - a)
    println(a + (a - a))
}
----

Получим

----
[]
[a]
----

[upperroman,start=4]
. Переполнение целых чисел со знаком иногда приводит к неприятным последствиям (подробнее обсудим в следующей задаче).
. (Из ответов студентов прошлых лет) Считаем `"a + a – a"` и `"a + (a – a)"` строками, очевидно, они не равны.
. Любые другие разумные объяснения допустимы

== Задание 3

Поменять значения двух целочисленных переменных местами (без привлечения третьей переменной и файлов).

=== Решения

==== Решение любителей Python

[source,python]
----
a, b = b, a
----

Решение работает и в общем удовлетворяет условию.

Давайте разберёмся, как оно работает!

===== Объяснение от DeepSeek

В Python операция `a, b = b, a` позволяет обменивать значения переменных без использования временной переменной.
Это работает благодаря механизму кортежей и распаковки.
Вот пошаговое объяснение:

[arabic]
. Создание кортежа справа:
* Выражение `b, a` автоматически создает кортеж `(b, a)`.
Например, если `a = 1` и `b = 2`, то справа формируется кортеж `(2, 1)`.
. Распаковка кортежа слева:
* Левой части `a, b` присваиваются элементы кортежа по порядку.
Первый элемент кортежа идет в первую переменную, второй — во вторую.
* В примере: `a` получает `2`, `b` получает `1`.

===== Дополнение от меня

Если полагаться на смысл языковых конструкций, то объяснение правильное.
Но давайте заглянем под капот.

Рассмотрим поведение на примере CPython, эталонной реализации языка и скорее всего привычной вам
(в других реализациях реальное поведение будет другим).

Программа на Python выполняется интерпретатором.
Сначала исходный код транслируется в https://docs.python.org/3/glossary.html#term-bytecode[байткод]
виртуальной https://en.wikipedia.org/wiki/Stack_machine[стековой машины], который затем интерпретируется.

Напишем небольшую программу на Python с использованием модуля `dis`, который позволяет анализировать байткод.

[source,python,linenums]
----
import dis

a = 1
b = 2

def swap():
    a, b = b, a

dis.dis(swap)
----

Рассмотрим вывод этой программы.

[IMPORTANT]
====
Для запуска использовался интерпретатор Python версии 3.12.
Для других версий вывод может отличаться.
====

Нас будет интересовать блок, соответствующий 7й строке исходного кода (`a, b = b, a`).
Сначала на стек кладутся (команда https://docs.python.org/3/library/dis.html#opcode-LOAD_FAST_CHECK[`LOAD_FAST_CHECK`])
значения переменных `b` и `a`.
А затем со стека эти значения сохраняются в переменные `a` и `b` (команда https://docs.python.org/3/library/dis.html#opcode-STORE_FAST[`STORE_FAST`]).

----
  6           0 RESUME                   0

  7           2 LOAD_FAST_CHECK          0 (b)
              4 LOAD_FAST_CHECK          1 (a)
              6 STORE_FAST               0 (b)
              8 STORE_FAST               1 (a)
             10 RETURN_CONST             0 (None)
----

То есть такое решение хоть и не использует ещё одну переменную, но использует 2 дополнительные ячейки памяти для сохранения значений.
С другой стороны, решения рассмотренные далее в случае CPython тоже активно сохраняют значения на стек и даже активнее, чем в данное
(что поделать, специфика стековой машины).

==== Решение с арифметикой

[TIP]
====
Идея: давайте сохраним в одной из переменных информацию об обеих, но так, чтобы можно было восстановить её значение.
====

Давайте подумаем, что можно сделать с целочисленными переменными…
Их можно складывать и вычитать!

[source,c]
----
a = a + b;
----

Теперь переменная `a` содержит информацию об обоих значениях, а старое можно восстановить с помощью вычитания: `a - b`.

[source,c]
----
b = a - b;
----

Теперь переменная `b` хранит старое значение переменной `a`.
Переменная `a` всё ещё хранит информацию об обоих значениях, что позволяет восстановить старое значение переменной `b`.

[source,c]
----
a = a - b;
----

Ура, переменные поменялись своими значениями!

Попробуйте позапускать программу, передавая ей различные значения.

.3_simple.c
[source,c]
----
#include <stdio.h>

int main() {
	int a, b;
	printf("Initialize values:\na = ");
	scanf("%i", &a);
	printf("b = ");
	scanf("%i", &b);

	// Swap
	a = a + b;
	b = a - b;
	a = a - b;

	printf("After swap:\na = %i\nb = %i\n", a, b);
	return 0;
}
----

[NOTE]
====
Давайте разберёмся, как компилировать и запускать программу на C.
Пусть мы сохранили исходный текст в файл `3_simple.c`.

Чтобы скомпилировать, выполним команду:

[source,shell]
----
gcc -o 3_simple 3_simple.c
----

`gcc`:: компилятор языка C (на будущих занятиях разберём, почему это не совсем так и почему мы продолжим называть его компилятором)
`-o 3_simple`:: опция, указывающая в какой файл сохранить результат компиляции

Чтобы запустить, выполним команду:

[source,shell]
----
./3_simple
----

====

===== Что же с этим решением не так?

Проблема в потенциальном переполнении в операции сложения `a = a + b`, если переменные `a` и `b` знаковые.

Переполнение знаковых целых чисел в языке C приводит к *Undefined Behavior (UB, неопределённое поведение)*!!!
С точки зрения стандарта языка C при возникновении UB поведение программы может стать *абсолютно непредсказуемым*!
Таких ситуаций нужно избегать!

Давайте проверим, что в написанной программе действительно может возникать UB.
Для этого перекомпилируем программу с использованием UndefinedBehaviorSanitizer (UBSan).
Это динамический анализатор кода (то есть анализирующий программу во время её работы),
который поддерживается компиляторами GCC и Clang и помогает обнаруживать UB.

[source,shell]
----
gcc -fsanitize=undefined -o 3_simple 3_simple.c
----

Запустим приложение и введём значения

----
a = 2000000000
b = 2000000001
----

[WARNING]
====
Отмечу, что размер типа `int` зависит от компилятора и платформы, под которую код компилируется.

В моём случае `sizeof(int) == 4`, то есть переменная типа `int` занимает 4 байта и может хранить значения в промежутке
stem:[[-2^{31},2^{31} - 1\]].
====

Получим вывод.

----
3_simple.c:11:8: runtime error: signed integer overflow: 2000000000 + 2000000001 cannot be represented in type 'int'
3_simple.c:12:8: runtime error: signed integer overflow: -294967295 - 2000000001 cannot be represented in type 'int'
3_simple.c:13:8: runtime error: signed integer overflow: -294967295 - 2000000000 cannot be represented in type 'int'
After swap:
a = 2000000001
b = 2000000000
----

Видим, что санитайзер сообщил об ошибке связанной с переполнением знакового целого
(сообщил об этом 3 раза, так как при вычитании переполнение также возникает).

[NOTE]
====
Поскольку уже несколько раз упоминался стандарт языка C, то давайте немного его обсудим.

Во-первых, стандартов языка несколько, так как есть несколько версий языка: C89, C99, C11 и другие.
Пока мы будем опираться на стандарт для C99.
Публикуется стандарт Международной организацией по стандартизации (ISO).
Документ, являющийся стандартом языка C, называется https://www.iso.org/standard/29237.html[ISO/IEC 9899:1999].
И он платный…

Однако перед принятием стандарта он активно обсуждается соответствующим комитетом, который публикует
https://www.open-std.org/JTC1/SC22/WG14/www/projects#9899[черновики], доступные бесплатно.

Зачем же нужен стандарт?:: Он помогает программистам писать переносимые программы,
которые будут вести себя стабильно на разных платформах.
Что там можно вычитать полезного?:: Какие есть допустимые синтаксические конструкции в языке,
как эти конструкции должны себя вести при работе программы, какие функции есть в стандартной библиотеке,
в каких ситуациях возникает Undefined Behavior и многое другое.
Можно ли пользоваться стандартом как учебником по языку C?:: Не стоит. Стандарт скорее поможет понять,
почему программа ведёт себя именно так, как она себя ведёт.
====

==== Решение с битовыми операциями

[TIP]
====
Давайте воспользуемся идеей прошлого решения, но избавимся от проблемы с UB.
====

Какие операции можно выполнять с целочисленными переменными, кроме арифметических? -- Побитовые.
Они замечательны тем, что не вызывают переполнений.

Среди них обратим внимание на https://en.wikipedia.org/wiki/Exclusive_or[XOR] (исключающее «или», stem:[\oplus]).

Нам понадобятся некоторые свойства этой операции.

* stem:[a \oplus 0 = a]
* stem:[a \oplus a = 0]
* stem:[a \oplus b = b \oplus a]
* stem:[(a \oplus b) \oplus c = a \oplus (b \oplus c)]


Тогда следующий алгоритм решает нашу задачу (stem:[a_{old}, a_{temp}, a_{new}] -- отражают версию значения в переменной stem:[a]).

. stem:[a_{temp} := a_{old} \oplus b_{old}]
. stem:[b_{new} := a_{temp} \oplus b_{old} = (a_{old} \oplus b_{old}) \oplus b_{old} = a_{old} \oplus (b_{old} \oplus b_{old}) = a_{old} \oplus 0 = a_{old}]
. stem:[a_{new} := a_{temp} \oplus b_{new} = (a_{old} \oplus b_{old}) \oplus a_{old} = (a_{old} \oplus a_{old}) \oplus b_{old} = 0 \oplus b_{old} = b_{old}]

[TIP]
====
Достаточно понять, почему это работает для однобитового значения, так как далее мы будем пользоваться побитовым XOR,
который будет применяться к паре соответствующих битов независимо от остальных.
====

.3_xor.c
[source,c]
----
#include <stdio.h>

int main() {
	int a, b;
	printf("Initialize values:\na = ");
	scanf("%i", &a);
	printf("b = ");
	scanf("%i", &b);

	// Good swap
	a ^= b; // a = a ^ b
	b ^= a;
	a ^= b;

	printf("After swap:\na = %i\nb = %i\n", a, b);
	return 0;
}
----

Скомпилируем программу с UBSan и проверим, что она отрабатывает без предупреждений.

[source,shell]
----
gcc -fsanitize=undefined -o 3_xor 3_xor.c
----

Запустим и введём те же значения, которые вызвали проблемы в предыдущем способе решения.

----
a = 2000000000
b = 2000000001
----

Получаем вывод.

----
After swap:
a = 2000000001
b = 2000000000
----

== Задача 4

Написать алгоритм нахождения неполного частного от деления a на b (целые числа), используя только операции сложения, вычитания и умножения.

=== Решение

Давайте разобьём задачу на случаи, каждый из которых решить достаточно легко.

* Деление натуральных числел.
* Деление на 0.
* Деление чисел со знаком.

==== Деление натуральных.

Сделать это можно, вычитая `b` из `a` пока `a >= b`.

Код на C будет выглядеть примерно так.

[source,c]
----
int div_nat(int a, int b) {
	int res = 0;

	// На C цикл можно было бы написать так
	// for (;a >= b; a -= b, ++res) { }
	// Но в таком стиле надо писать с осторожностью,
	// т.к. страдает читаемость
	while (a >= b) {
		a -= b;
		res++;
	}
	return res;
}
----

Аналогично можно сделать через умножение.

==== Обработка деления на 0

Тут всё просто: если `b == 0`, то сообщаем пользователю, что на `0` делить нельзя и завершаем программу с ошибкой.

[IMPORTANT]
====
Очень важно проверять пользовательский ввод на корректность.
Пользователь непредсказуем.
Он мог опечататься, не разобраться, как пользоваться программой, специально попытаться сломать программу и т.д.

Аналогичный совет можно дать при разработке библиотек: обязательно проверять (валидировать) входные аргументы функций,
которые может вызвать пользователь вашей библиотеки.
====

Давайте посмотрим, как можно сделать проверку пользовательского ввода на C.

[source,c]
----
int main() {
	int a, b;
	printf("Input values:\na = ");
	if (scanf("%d", &a) != 1) {
		fprintf(stderr, "Cannot read value, a must be an integer number\n");
		return 1;
	}
	printf("b = ");
	if (scanf("%d", &b) != 1) {
		fprintf(stderr, "Cannot read value, b must be an integer number\n");
		return 1;
	}

	if (b == 0) {
		fprintf(stderr, "b must not be 0\n");
		return 1;
	}

	... // Тут остальная логика по делению в допустимом случае
	return 0;
}
----

Здесь нам будут интересны 3 конструкции.

[arabic]
. `if (scanf("%d", &a) != 1)` рассмотрим её части.
* Функция `scanf` -- функция стандартной библиотеки, позволяющая читать форматированный пользовательский ввод со _стандартного потока ввода_ (чуть подробнее обсудим, что это такое).
В случае успешного выполнения возвращает неотрицательное число -- число успешно прочитанных аргументов.
Оно может быть меньше числа аргументов, которые мы пытаемся прочитать! Поэтому сравниваем это значение с `1` (так как пытаемся прочитать одно число).
* `"%d"` -- строка, описывающая ожидаемый формат ввода и управляющая поведением функции.
Из того, что в этой строке может быть, нас сейчас будут интересовать спецификации формата -- кострукции, начинающиеся со знакак процента (`%...`).
Подробно о том, как строятся спецификации, стоит прочитать в документации, но для нас сейчас достаточно будет знать, что вначале идёт символ процента, а в конце -- символ, специфицирующий преобразование.
В данном случае используется `"%d"`, который говорит, что необходимо прочитать и сохранить целочисленное значение в десятичной системе счисления.
* `&a` -- аргумент функции, описывающий, куда надо сохранить прочитанное значение.
`&a` означает взятие адреса переменной `a` в памяти.
Чтобы функция могла изменить значение переменной (что мы явно хотим сделать при чтении значения в переменную), необходимо передать в функцию её адрес (а не значение переменной).
. `fprintf(stderr, "Cannot ...)`
* Для начала скажем о функции `printf(...)`.
Это функция, которая позволяет делать форматированный вывод в _стандартный поток вывода_.
Также первым аргументом принимает строку, описывающий формат вывода, в которой также содержаться спецификации формата для печати остальных аргументов.
* Функция `fprintf(...)` отличается от `printf` тем, что позволяет первым аргументом указать, куда делать вывод, то есть в какой поток вывода.
Например, `fprintf(stdout, ...)` эквивалентна `printf(...)`, так как производит вывод в _стандартный поток вывода_.
А `fprintf(stderr, ...)` производит вывод в _стандартный поток ошибок_.
. `return 1;`
Возвращаемое функцией `main()` значение используется как https://en.wikipedia.org/wiki/Exit_status[код возврата программы (exit status, exit code)].
Значение `0` трактуется как нормальное завершение, остальные значения -- произошла ошибка.

[NOTE]
====
Поскольку несколько раз упоминались потоки ввода/вывода, давайте обсудим их поподробнее.

Что такое потоки ввода/вывода идейно?:: Абстракция, из которой можно читать/в которую можно писать последовательность данных.
Как потоки ввода вывода выглядят в C?:: В виде переменных, имеющих тип `FILE *`.
А откуда они читают/куда пишут?:: Это может быть какое-нибудь устройство, например клавиатура, может быть обычный файл, может быть терминал и т.д.
А как реализовано под капотом?:: По разному. В Unix-like системах через механизм файловых дескрипторов (https://en.wikipedia.org/wiki/File_descriptor[file descriptors]), в Windows -- через хендлы (https://learn.microsoft.com/en-us/windows/win32/fileio/file-handles[HANDLE])
А что за _стандартные потоки ввода, вывода, ошибок_?:: Это 3 стандартных потока, которые есть у программы с начала её работы.

* `stdin` -- стандартный поток ввода, используется для чтения программой данных (обработка пользовательского ввода).
* `stdout` -- стандарный поток вывода, используется для вывода данных (показать пользователю результат работы).
* `stderr` -- стандартный поток ошибок, используется, чтобы делать диагностический вывод (вывести сообщение о том, что что-то идёт не так).

Чаще всего при запуске ваших программ все 3 стандартных потока ввода/вывода будут связаны с терминалом, из которого вы вызвали программу.
То есть чтение будет происходить из терминала, обычный вывод и вывод ошибок тоже будет в терминал (поэтому визуально вы их не отличите).Однако при вызове программы в терминале есть способы перенаправить эти потоки, например, с помощью конструкций: 

* `< имя_файла` -- перенапрвавляет поток ввода, т.е программа будет читать из файла;
* `> имя_файла` -- перенаправляет поток вывода в файл;
* `2> имя_файла` -- перенаправляет поток ошибок в файл;
* `| следующая_программа` -- перенаправляет поток вывода запускаемой программы на стандартный вход следующей программы.
====

==== Обработка чисел со знаком

Поскольку в условии сказано, что `a` и `b` -- целые числа, то разумным видиться обработка ситуаций, когда числа могут быть отрицательными.

Мы уже умеем делить натуральные числа, а даже точнее `a` stem:[\in \mathbb{N} \cup \{ 0 \}], `b` stem:[\in \mathbb{N}].
Отметим, что результат будет неотрицательным, если `a` -- неотрицательное и `b` -- положительное, либо `a` -- отрицательное и `b` -- отрицательное.
В остальных случаях ответ будет отрицательным.

Тогда обработка этих ситуаций может выглядеть следующим образом.

[source,c]
----
	int quotient;
	if (a * b < 0) {
		quotient = - ((a < 0) ? div_nat(-a, b) : div_nat(a, -b));
	} else {
		quotient = (b < 0) ? div_nat(-a, -b) : div_nat(a, b);
	}
	printf("Result: %i\n", quotient);
----

Однако тут есть 2 важных замечания.

.Замечание 1
[WARNING]
====
`a * b < 0` -- удобный способ, но может приводить к переполнениям (разобрали проблему в решении прошлой задачи).

Подумайте, как избавиться от этой проблемы в данном случае.
====

.Замечание 2
[WARNING]
====
На самом деле в этом коде принято некоторое неочевидное решение о делении с остатком.
Давайте рассмотрим поведение двух похожих программ на C и Python.

.div.c
[source,c]
----
#include <stdio.h>

int main(void) {
	printf("-3 / 2 = %d\n", -3 / 2);
	printf("-3 %% 2 = %d\n", -3 % 2);
	return 0;
}
----

Результат её работы.

----
-3 / 2 = -1
-3 % 2 = -1
----

.div.py
[source,python]
----
print(f"-3 / 2 = {-3 // 2}")
print(f"-3 % 2 = {-3 % 2}")
----

Результат её работы.

----
-3 / 2 = -2
-3 % 2 = 1
----

Видим, что результат отличается.
А как должно быть?

В математике разделить stem:[a] на stem:[b] с остатком означает найти такие целые stem:[q] и stem:[0 \leq r \lt |b|], что

[stem]
++++
a = b * q + r
++++

То есть в математике остаток должен быть неотрицательным, а вот в языках программирования может быть по-разному.
Обращайте на это внимание!

Например стандарт С говорит.

____
When integers are divided, the result of the / operator is the algebraic quotient with any fractional part discarded.
If the quotient `a/b` is representable, the expression `(a/b)*b + a%b` shall equal `a`.
____

Отсюда остаток `a%b = a - (a/b)*b`.
Тогда он будет иметь знак _делимого_.

[source,c]
----
#include <stdio.h>

int main(void) {
	printf("3 / -2 = %d\n", 3 / -2);
	printf("3 %% -2 = %d\n", 3 % -2);
	return 0;
}
----

Результат работы:

----
3 / -2 = -1
3 % -2 = 1
----

В задаче, конечно, не требовалось находить остаток!
Но понимание работы деления с остатком нужно для выбора подхода к округлению результата.

Например, в представленном мною решении делается округление к 0, то есть поведение похоже на C.
====

Тогда вся программа (с точностью до проблемы с перепольнением может выглядеть так).

[source,c]
----
#include <stdio.h>

int div_nat(int, int);

int main() {
	int a, b;
	printf("Input values:\na = ");
	if (scanf("%d", &a) != 1) {
		fprintf(stderr, "Cannot read value, a must be an integer number\n");
		return 1;
	}
	printf("b = ");
	if (scanf("%d", &b) != 1) {
		fprintf(stderr, "Cannot read value, b must be an integer number\n");
		return 1;
	}

	if (b == 0) {
		fprintf(stderr, "b must not be 0\n");
		return 1;
	}

	int quotient;
	if (a * b < 0) {
		quotient = - ((a < 0) ? div_nat(-a, b) : div_nat(a, -b));
	} else {
		quotient = (b < 0) ? div_nat(-a, -b) : div_nat(a, b);
	}
	printf("Result: %i\n", quotient);
	return 0;
}

int div_nat(int a, int b) {
	int res = 0;
	while (a >= b) {
		a -= b;
		res++;
	}
	return res;
}
----

== Задача 5

Дан массив целых чисел x[1]…x[m+n], рассматриваемый как соединение двух его отрезков: начала x[1]…x[m] длины m и конца x[m+1]…x[m+n] длины n. Не используя дополнительных массивов, переставить местами начало и конец.

=== Решения

==== Простейшее решение

Давайте `n` раз циклически сдвинем массив на 1 элемент.

Что надо сделать для циклического сдвига (с учётом индексации из условия):

* `x[i] = x[i - 1]` (кроме `i == 1`)
* `x[0] = x[m + n]` (`x[m + n]` надо заранее запомнить, чтобы на прошлом шаге он не перезатёрся)

Итого получим какой-то такой код на C (с индексацией массивов как в C)

[source,c]
----
	for (int i = 0; i < n; ++i) {
		int temp = arr[m + n - 1];
		for (int j = m + n - 1; j > 0; --j) {
			arr[j] = arr[j - 1];
		}
		arr[0] = temp;
	}
----

Давайте немного его соптимизируем.
Для этого заметим, что при сдвиге на 1 только первой части массива (с индексами `[1..m]`) мы перетираем 1 элемент второй части.
Однако мы освобождаем 1 элемент, и что самое замечательное, тот элемент, на который должен был попасть перетираемый элемент из второй части.
Тогда можно этим воспользоваться и поставить его сразу на место.

Пусть `m == 9`, `n == 5` (квадратными скобками будет выделяться первая часть).

----
[0, 1, 2, 3, 4, 5, 6, 7, 8], 9, 10, 11, 12, 13
9, [0, 1, 2, 3, 4, 5, 6, 7, 8], 10, 11, 12, 13
9, 10, [0, 1, 2, 3, 4, 5, 6, 7, 8], 11, 12, 13
9, 10, 11, [0, 1, 2, 3, 4, 5, 6, 7, 8], 12, 13
9, 10, 11, 12, [0, 1, 2, 3, 4, 5, 6, 7, 8], 13
9, 10, 11, 12, 13, [0, 1, 2, 3, 4, 5, 6, 7, 8]
----

В таком решении приходится сдвигать меньшее число элементов: в базовом решении надо было двигать весь массив, а в этом -- только первую часть.

[source,c]
----
	for (int i = 0; i < n; ++i) {
		int temp = arr[m + i];
		for (int j = m + i; j > i; --j) {
			arr[j] = arr[j - 1];
		}
		arr[i] = temp;
	}
----

==== Решение с разворотами массива

У данной задачи есть очень элегантное решение.

Давайте развернём массив и посмотрим, что с ним произойдёт.

----
Исходный массив
[0, 1, 2, 3, 4, 5, 6, 7, 8], 9, 10, 11, 12, 13

Массив после разворота
13, 12, 11, 10, 9, [8, 7, 6, 5, 4, 3, 2, 1, 0]
----

Нужные части массивов попали в нужные места, только элементы идут в обратном порядке.
Осталось выполнить разворот каждой части, и задача решена.

Примерно так может выглядеть код программы, решающей задачу.

.5.c
[source,c]
----
#include <stdio.h>
#include <stdlib.h>


#define MAX_ARRAY_SIZE 100 // <1>

void reverse_array(int *arr, int start, int end) {
	int size = end - start;
	for (int i = 0; i < size / 2; ++i) {
		int temp = arr[start + i];
		arr[start + i] = arr[start + size - i];
		arr[start + size - i] = temp;
	}
}

int main(int argc, char *argv[]) { // <2>
	if (argc != 3) {
		printf("Invalid number of arguments\nUsage: %s <m> <n>\n", argv[0]); // <3>
		return 1;
	}
	int m = atoi(argv[1]); // <4>
	int n = atoi(argv[2]);
	if (m * n <= 0 || m + n > MAX_ARRAY_SIZE) {
		printf("Invalid arguments\n")
		printf("m and n must be greater than 0 and m + n <= %d\n", MAX_ARRAY_SIZE);
		return 1;
	}

	int arr[MAX_ARRAY_SIZE] = {0};
	printf("Original array:\n[");
	for (int i = 0; i < m; ++i) {
		arr[i] = i;
		printf("\033[0;31m%d\033[0m, ", i); // <5>
	}
	for (int i = m; i < m + n; ++i) {
		arr[i] = i;
		printf("\033[0;32m%d\033[0m, ", i);
	}
	printf("]\n");

	// Super-shift
	reverse_array(arr, 0, m + n - 1);
	reverse_array(arr, 0, n - 1);
	reverse_array(arr, n, n + m - 1);

	printf("Array after shift\n[");
	for (int i = 0; i < n; ++i) {
		printf("\033[0;32m%d\033[0m, ", arr[i]);
	}
	for (int i = n; i < n + m; ++i) {
		printf("\033[0;31m%d\033[0m, ", arr[i]);
	}
	printf("]\n");
	
	return 0;
}
----

Давайте посмотрим на новые конструкции, которые я напихал в код.

<1> `#define MAX_ARRAY_SIZE 100` -- это директива препроцессора (то есть команда препроцессору), говорящая ему определить макрос с именем `MAX_ARRAY_SIZE`, значением которого будет `100`.
Важно отметить, что во ВСЕХ местах использования этого макроса в коде на первом шаге компиляции подставится `100`.
То есть это не просто способ определить константное значение, а способ на уровне обработки исходного кода подменить одну строку другой.
Ради интереса рекомендую посмотреть, как препроцессор меняет ваш код, для этого при компиляции передайте опцию `-E`.
Но вывод произойдёт в терминал, поэтому рекомендую перенаправить вывод либо в файл (`gcc -E 5.c > 5.i`), который потом можно будет открыть в удобном редакторе, либо на вход программе-просмотрщику текстовых файлов (`gcc -E 5.c | less`).
<2> Оказывается, функция `main` может принимать аргументы.
Называются они аргументами командной строки и являются ещё одним способом передать информацию программе.
Например, в нашем случае мы передаём значения для `m` и `n`.
При запуске программы в терминале передаваемые аргуметны отделяются пробелами: `./5_solution 9 5`.
Обычно называются они `argc` и `argv`.

* `argc` -- целое число, которое хранит число аргументов.
* `argv` -- массив строк (потом обсудим, почему `char *argv[]` -- массив строк, и почему `char **argv` -- тоже массив строк), который в каждом элементе хранит очередной аргумент.

<3> `argv[0]` хранит в себе строку, содержащую _имя программы_ (в нашем случае мы увидим имя файла, который запускали в терминале).
<4> `argv[1]` содержит строку, чтобы преобразовать её в число, используется функция стандартной библиотеки `atoi` (это не единственная функция, позволяющая преобразовывать строки в числа).
<5> В форматной строке у `printf(...)` видим, какие-то заклинания.
Это управляющие последовательности (https://en.wikipedia.org/wiki/ANSI_escape_code[escape sequences]) для терминала.
Если быть более точным то для эмулятора терминала (вряд ли вы сидите за физическим терминалом), программы, которая ведёт себя как https://en.wikipedia.org/wiki/Computer_terminal[терминал].
Такие последовательности не печатаются на экран, а используются для управления терминалом, например в данной строке есть 2 последовательности: `"\033[0;31m"` -- сделать цвет печатаемого текста красным, `"\033[0m"` -- сбросить настройки.
Подобные последовательности позволяют не только менять цвет текста, но и многое другое.

==== Другие решения

У данной задачи есть ещё пара красивых решений.
Рекомендую посмотреть видео https://www.youtube.com/watch?v=fVzvl9jJEv8[Почему программистам не нужна математика].
В нём разбираются эти решения, а также более подробно рассматривается решение с тремя поворотами.

== Задача 6

Подсчитать число «счастливых билетов» (билет считается «счастливым», если сумма первых трёх цифр его номера равна сумме трёх последних).

=== Решения

Для начала дам https://ru.wikipedia.org/wiki/%D0%A1%D1%87%D0%B0%D1%81%D1%82%D0%BB%D0%B8%D0%B2%D1%8B%D0%B9_%D0%B1%D0%B8%D0%BB%D0%B5%D1%82[ссылку], которая объяснит, о чём вообще речь (возможно, вы уже не видели бумажных билетиков в автобусах).

А ещё давайте решим, что билет с номером `000000` существует (так кода поменьше будет).
Если что, то нам будет достаточно сделать поправку на 1 в ответе.

==== Простейшее решение

Давайте переберём все возможные билеты и посчитаем число счастливых.

Это можно сделать, например, перебирая само число (от `0` до `999999`), но в таком случае надо будет разбивать его на разряды, складывать их значения и т.д.
На мой взгляд сильно проще перебрать все возможные значения каждого разряда.
Получится какое-то такое решение.

[source,c]
----
#include <stdio.h>

int simple() {
	int res = 0;
	for (int i1 = 0; i1 < 10; ++i1)
	for (int i2 = 0; i2 < 10; ++i2)
	for (int i3 = 0; i3 < 10; ++i3)
	for (int i4 = 0; i4 < 10; ++i4)
	for (int i5 = 0; i5 < 10; ++i5)
	for (int i6 = 0; i6 < 10; ++i6)
		if (i1 + i2 + i3 == i4 + i5 + i6)
			res++;
	return res;
}

int main() {
	int res = simple();
	printf("%d\n", res);
	return 0;
}
----

Очевидно, что нам приходится перебирать очень много.
Можно придумать более общую задачу, в которой число на билете будет состоять не из 6 чисел, а из произвольного.
В таком случае данное решение будет работать неразумно долго (даже на небольших длинах, например, 12).
Давайте попробуем его исправить.

==== Подсчёт сумм

Главная идея -- посчитать число способов набрать каждую возможную сумму в половинке билета.
Давайте поймём, как ей воспользоваться.

Пусть мы посчитали в массиве `s` это число способов.
То есть `s[x]` содержит число комбинаций из трёх цифр, дающих в сумме `x`.
Заметим, что размер такого массива не очень большой: минимальная сумма -- `0` (половинка с номером `000`), максимальная -- `27` (половинка с номером `999`).

Пусть в билете в первой половине сумма `X`, тогда чтобы билетик был счастливым, то во второй половине должна быть одна из `s[X]` комбинаций.
Отсюда понимаем (по правилу умножения из комбинаторики), что всего билетиков, в которых в каждой половинке сумма `X` будет всего `s[X] * s[X]`.

И сходу можем оптимизировать предыдущее решение: давайте перебирать половину цифр и подсчитывать, сколько раз встречаются суммы, а потом посчитаем, сколько билетиков может быть с каждой.

[source,c]
----
#include <stdio.h>

#define MAX_LEN 28

int count_sums() {
	int sums_count[MAX_LEN] = {0};
	for (int i1 = 0; i1 < 10; ++i1)
	for (int i2 = 0; i2 < 10; ++i2)
	for (int i3 = 0; i3 < 10; ++i3)
		sums_count[i1 + i2 + i3]++;
	int res = 0;
	for (int i = 0; i <= 27; ++i) {
		res += sums_count[i] * sums_count[i];
	}
	return res;
}

int main() {
	int res = count_sums();
	printf("%d\n", res);
	return 0;
}
----

Мы уменьшили перебор в 2 раза (немного пожертвовав памятью), но если число цифр будет увеличиваться, то работать будет всё ещё достаточно долго.

==== Пересчёт сумм

Давайте ещё пожертвуем памятью, чтобы решить задачу ещё быстрее.
Будем развивать предыдущую идею.

Пусть половинка номера билета имеет длину stem:[l], и мы уже знаем число способов получить все возможные суммы с помощью stem:[l] цифр (stem:[S^l]).
Давайте поймём, как получить число способов получить все возможные суммы с помощью stem:[l + 1] цифры (stem:[S^{l+1}]).

Пусть мы хотим получить число способов набрать сумму stem:[X], то есть число stem:[S_X^{l+1}].
Сумму stem:[X] мы могли получить из 

* stem:[X] добавлением stem:[0], число способов -- stem:[S_X^l];
* stem:[X - 1] добавлением stem:[1], число способов -- stem:[S_{X-1}^l];
* ...
* stem:[X - 9] добавлением stem:[9], число способов -- stem:[S_{X-9}^l].

Осталось сложить эти числа.
То есть stem:[S_X^{l+1} = \displaystyle\sum_{d=0}^9 S_{X-d}^l] (тут при написании кода важно следить за выходом за границы, если явно реализовывать по формуле).

Ну и очевидно, что каждая возможная сумма при половинке из одной цифры достигается единственным способом (этой самой цифрой).

Тогда решение может выглядеть так.

[source,c]
----
#include <stdio.h>

#define MAX_LEN 100

int recount_sums(int len) {
	int sums_count[MAX_LEN / 2][MAX_LEN * 10] = {0};
	for (int i = 0; i < 10; ++i) {
		sums_count[0][i] = 1;
	}
	for (int i = 1; i < len / 2; ++i) {
		for (int j = 0; j < 9 * i + 1; ++j) {
			for (int k = 0; k < 10; ++k) {
				sums_count[i][j + k] += sums_count[i - 1][j];
			}
		}
	}
	int res = 0;
	for (int i = 0; i < 9 * (len / 2) + 1; ++i) {
		res += sums_count[len / 2 - 1][i] * sums_count[len / 2 - 1][i];
	}
	return res;
}

int main() {
	int res = recount_sums(6);
	printf("%d\n", res);
	return 0;
}
----

Такое решение будет отрабатывать практически мгновенно для билетиков с номером длины `100`
(но таких билетов ооооочень много и переменная с результатом переполнится, лучше для подсчёта чего-либо использовать беззнаковые переменные, так как их переполнение не приводит к UB).
Также можно отметить, что для пересчёта сумм здесь выделяется слишком много памяти (сейчас выделяется по массиву на каждую длину, а можно обойтись всего двумя: для подсчитанной на предыдущем шаге и для подсчитываемой на текущем).

== Задача 7

Написать алгоритм проверки баланса скобок в исходной строке (т.е. число открывающих скобок равно числу закрывающих и выполняется правило вложенности скобок).

=== Решения

==== Для одного типа скобок

Очевидно, что просто посчитать число открывающих и закрывающих скобок недостаточно, так как их число ничего не говорит о вложенности.
Давайте поймём, что общего у следующих неправильных последовательностей.

* `)()(`
* `(()))()`
* `(())())`

В какой-то момент мы встречаем закрывающую скобку, для которой нет соответствующей открывающей левее.
То есть в какой-то момент число закрывающих превысило число открывающих.

Можно подсчитывать эти числа и постоянно сравнивать.
А можно завести переменную, которая будет хранить число открывающих скобок, для которых ещё не найдена соответствующая закрывающая.
Тогда алгоритм очень прост:

* Встретили открывающую -- увеличиваем переменную;
* Встретили закрывающую -- уменьшаем переменную;
* Если в какой-то момент переменная стала меньше нуля -- последовательность неправильная;
* Если в конце переменная не ноль -- последовательность неправильная.

На C это можно написать примерно так.

[source,c]
----
#include <stdio.h>

#define BUF_SIZE 100

int check_parentheses_seq(char *buf) { // <3>
	int opened = 0;
	for (char *p = buf; *p; ++p) { // <4>
		opened += (*p == '(') ? 1 : -1;
		if (opened < 0) {
			return 0;
		}
	}
	if (opened > 0) {
		return 0;
	}
	return 1;
}

int main() {
	char buf[BUF_SIZE]; // <1>
	scanf("%s", buf); // <2>
	if (check_parentheses_seq(buf)) {
		printf("Good\n");
	} else {
		printf("Bad\n");
	}
	
	return 0;
}
----

.Сразу отмечу
[WARNING]
====
Использовать `scanf("%s...` для считывания строк *НЕБЕЗОПАСНО*!
Пользователь может ввести очень длинную строку, которая переполнит буфер, в который мы считываем строку.
Это может приводить к ужасным последствиям (будет занятие об этом).
Есть более подходящие способы, но пока для демонстраций буду использовать его, так как сейчас не занятие по безопасному программированию.
====

Давайте немного рассмотрим работу с массивами, строками и указателями в C (наверное, самой сложной темой, для тех, кто на C не программировал).

<1> Здесь мы выделяем массив на `BUF_SIZE` символов.
<2> Здесь мы считываем строку, которую ввёл пользователь в выделенный нами массив.
Сразу отмечу специфику строк в C: для них нет специального типа данных и операторов.
Строкой считается любой массив символов, заканчивающийся символом с кодом `0` (этим будем пользоваться при проходе по строке), такой способ называется https://en.wikipedia.org/wiki/Null-terminated_string[нуль-терминированная строка (null-terminated string, ASCIIZ, C strings)].
<3> Если мы хотим передать массив в функцию, то нас ждёт огорчение, в C мы можем передать адрес его начала, то есть *указатель* на массив, но не его самого (если быть честным, способ есть, но он очень неудобный, требует некоторого дополнительного кода, и так никто не делает).
В общем случае нам надо передать адрес начала массива и число элементов в нём (либо второй указатель, обозначающий конец), но в данном случае мы хотим передать строку, а на в её конце будет символ с кодом `0`, поэтому передаём только адрес начала.
Чтобы объявить такой аргумент надо дать ему тип указателя: тип `char *` означает, что значением будет адрес некоторого `char` (в нашем случае первого символа строки).
Тип указателя очень важен, так как позволяет правильно индексироваться по переданному массиву.
<4> В `p` сохраняется адрес начала. Далее нам будут интересны 2 конструкции.

* `*p` -- _разыменовать_ указатель, то есть взять значение по адресу, который хранится в указателе.
** Почему у нас такое выражение стоит в условии продолжения цикла?
Потому что в C условия работают так: если результат выражения равен нулю, то условие не выполняется, если результат равен чему-то отличному от нуля, то условие выполняется.
То есть то же самое условие можно записать так: `*p != 0` (но программисты на C нечасто пишут такие проверки).
** А почему такое условие мы используем для того, чтобы закончить проход по строке? Потому что в конце строки будет идти символ с кодом `0`.
То есть когда `p` будет указывать на этот символ, выражение `*p` вернёт `0`, и цикл завершится.
* `++p` -- сдвинуть указатель на 1 элемент «вперёд», то есть передвинуть его на следующий элемент массива.

В целом аналогичный код можно написать и с индексами (но я хотел показать, как это делать чисто через указатели).

[source,c]
----
int check_parentheses_seq(char *buf) {
	int opened = 0;
	for (int i = 0; buf[i]; ++i) {
		opened += (buf[i] == '(') ? 1 : -1;
		if (opened < 0) {
			return 0;
		}
	}
	if (opened > 0) {
		return 0;
	}
	return 1;
}
----

==== Решение для нескольких типов скобок

К сожалению, несколькими переменными, подсчитывающими баланс уже не обойтись.
В последовательности `[(])` скобки каждого типа сбалансированы между собой, но вот скобки разного типа конфликтуют, то есть закрывающая скобка не соответствует типу последней открывающей, ожидающей закрытия.

Давайте посмотрим на последовательность `[{}(])`.
И посмотрим, на то, какие скобки ожидают закрытия.

.Трассировка обработки
[%autowidth%header,cols="1,1,1"]
|===
| Обработанная последовательность | Текущая скобка | Скобки, ожидающие закрытия

|
| `[`
|

| `[`
| `{`
| `[`

| `[{`
| `}`
| `{`, потом `[`

| `[{}`
| `(`
| `[`

| `[{}(`
| `]`
| `(`, потом `[`
|===

Видим, что закрывать скобки надо в обратном порядке, относительно того, как они были открыты.
Для решения нам понадобиться структура данных, которая называется https://en.wikipedia.org/wiki/Stack_(abstract_data_type)[стек (stack)].
Она реализует доступ LIFO (last in, first out), то есть элементы будут извлекаться в обратном, относительно добавления порядке (а это то, что нам и надо).
Тогда алгоритм будет очень похож на случай с одним типом скобок:

* Встретили открывающую любого типа -- кладём её на стек;
* Встретили закрывающую -- смотрим на стек;
** Если стек пуст -- последовательность неправильная;
** Снимаем со стека открывающую скобку, если она не соответствует встреченной закрывающей -- последовательность неправильная;
* Если в конце стек что-то содержит -- последовательность неправильная.

На C это можно написать примерно так.

[source,c]
----
#include <stdio.h>

#define BUF_SIZE 100

int check_brackets_seq(char *buf) {
	char stack[BUF_SIZE];
	int top = -1;
	for (char *p = buf; *p; ++p) {
		if (*p == '(' || *p == '[' || *p == '{') {
			stack[++top] = *p;
		} else {
			if (top < 0
				|| (stack[top] == '(' && *p != ')')
				|| (stack[top] == '[' && *p != ']')
				|| (stack[top] == '{' && *p != '}')) {
				return 0;
			}
			top--;
		}
	}
	if (top >= 0) {
		return 0;
	}
	return 1;
}

int main() {
	char buf[BUF_SIZE];
	scanf("%s", buf);
	if (check_brackets_seq(buf)) {
		printf("Good\n");
	} else {
		printf("Bad\n");
	}
	
	return 0;
}
----

Ещё отмечу, что на самом деле решение для одного типа скобок в некотором смысле тоже использует стек.
Это понять нам помогут

* https://en.wikipedia.org/wiki/Peano_axioms[аксиоматика Пеано], в которой:
** stem:[x + 1 = S(S(\dots S(Z) \dots)) + 1 = S(S(S(\dots S(N) \dots)))] (как будто добавляем ещё одну stem:[S] на стек);
** stem:[x - 1 = S(S(\dots S(Z) \dots)) - 1 = S(\dots S(Z) \dots)] (как будто снимаем очередную stem:[S] со стека);
* https://en.wikipedia.org/wiki/Unary_numeral_system[унарная система счисления], в которой:
** stem:[x + 1 = 11 \dots 11 + 1 = 11 \dots 111] (как будто добавляем ещё одну stem:[1] на стек);
** stem:[x - 1 = 11 \dots 11 - 1 = 11 \dots 1] (как будто снимаем очередную stem:[1] со стека).


== Задача 8

Заданы две строки: S и S1. Найдите количество вхождений S1 в S как подстроки.

=== Решения

Для начала важно понять, хотим ли мы находить перекрывающиеся вхождения.
Например при `S = "ababa"`, а `S1 = "aba"`, что должна вернуть программа: `1` или `2`?
Так как в условии не обговаривался этот момент, то оба варианта допустимы, но важно понимать, как работает ваше решение.

==== Решения любителей Python

Наиболее частое решение, которое я успел повстречать.

[source,python]
----
S.count(S1)
----

Оно действительно решает поставленную задачу, но не учитывает перекрывающиеся вхождения.

Следующее решение уже использует регулярные выражения (такое я тоже в студенческих ответах встречал).
Решить можно несколькими способами и разной степени аккуратности, вот один из вариантов.

[source,python]
----
import re
...
len(re.findall(S1, S))
----

К сожалению, оно тоже не учитывает перекрывающиеся вхождения.

А можно ли стандартными средствами Python решить задачу, учитывая перекрывающиеся вхождения?
Ответ мне подсказал DeepSeek.
Можно воспользоваться синтаксисом опережения `?=` в регулярных выражениях.

[source,python]
----
import re
...
len(re.findall(f"(?=({S1}))", S))
----

==== Простое алгоритмическое решение

Дальше я буду называть строку `S1` паттерном, а `S` -- текстом.

Идея простая: пробегаем по символам текста, если очередной символ совпадает с первым символом паттерна, то запускаем цикл, который проверит, совпадают ли следующие символы.
Важно только не выйти за границы строк случайно.

Реализация на C тоже несложная.

[source,c]
----
int count_substrings_simple(char *pattern, char *text) {
	int count = 0;
	for (char *t = text; *t; ++t) {
		if (*t == *pattern) {
			int i;
			for (i = 0; t[i] && pattern[i] && t[i] == pattern[i]; ++i) {}
			if (!pattern[i]) {
				count++;
			}
		}
	}
	return count;
}
----

Такое решение работает с перекрывающимися вхождениями, но если надо без них, то его не очень сложно адаптировать.

==== Более крутые алгоритмические решения

Вообще алгоритмов, решающих данную задачу довольно много, очень рекомендую ознакомиться.

* http://e-maxx.ru/algo/rabin_karp[Алгоритм Рабина-Карпа], использующий хеш-функцию от строк.
* http://e-maxx.ru/algo/z_function#header_7[Основанный на Z-функции] (по ссылке сам алгоритм, прочитайте и то, что написано выше, чтобы понять, как алгоритм работает).
* http://e-maxx.ru/algo/aho_corasick[Алгоритм Ахо-Корасик], который строит https://en.wikipedia.org/wiki/Finite-state_machine[конечный автомат], позволяющий искать подстроки в строке (алгоритм решает более общую задачу)
* Алгоритмы, основанные на http://e-maxx.ru/algo/prefix_function[префикс-функции].

==== Решения, основанные на префикс-функции

Рассмотрим несколько решений, основанные на префикс-функции.
Они довольно интересные, а ещё удивительным образом на C можно очень коротко записать довольно сложный алгоритм.

Для начала определим префикс-функцию.

====
Префикс-функция строки stem:[s] -- массив stem:[\pi] такой, что stem:[\pi [i\] = \max_{k=0..i} \{k: s[0 \dots k-1\] = s[i - k + 1 \dots i\]\}], то есть это длина наибольшего собственного суффикса подстроки stem:[s[0 \dots i\]], совпадающего с её префиксом (собственный суффикс — значит не совпадающий со всей строкой, отсюда stem:[\pi[0\] = 0])
====

Реализуем её вычисление на C (почему алгоритм такой, вы узнаете по ссылке выше).

[source,c]
----
void prefix_function(char *str, int *pi) {
	pi[0] = 0;
	for (int i = 1; str[i]; ++i) {
		int j = pi[i - 1];
		while (j > 0 && str[i] != str[j]) {
			j = pi[j - 1];
		}
		if (str[i] == str[j]) {
			j++;
		}
		pi[i] = j;
	}
}
----


===== Явное применение

Давайте склеим наш паттерн и текст через какой-нибудь символ-разделитель, который не встречается ни в паттерне, ни в тексте
(для примера я возьму `'\#'`, хотя потенциально это не самый подходящий разделитель).
Получим строку `s = pattern + '#' + text` для которой посчитаем префикс-функцию.

Поскольку разделитель не встречается в тексте, то наибольшее значение префикс-функции -- длина префикса.
Более того, если для какого-то `i` значение префикс-функции равно длине префикса, то мы нашли его вхождение в тексте.

Осталось только посчитать, сколько таких значений есть в префикс-функции.
Это будет ответ.

На C можно реализовать примерно так.

[source,c]
----
int count_substrings_pi(char *pattern, char *text) {
	char s[MAX_PATTERN_SIZE + MAX_TEXT_SIZE + 1] = {0};
	int pi[MAX_PATTERN_SIZE + MAX_TEXT_SIZE + 1] = {0};
	sprintf(s, "%s#%s", pattern, text); // Надо быть ооочень уверенным, что результат поместится
	prefix_function(s, pi);
	int count = 0;
	for (int i = 0; s[i]; ++i) {
		if (s[pi[i]] == '#') {
			count++;
		}
	}
	return count;
}
----

===== Алгоритм Кнута-Морриса-Пратта (КМП)

Поскольку значение префикс-функции в предыдущем решении не превосходит длину паттерна, то мы можем не хранить её для символов текста, так как они никак не влияют на её значение для следующих символов.
Точнее влияют, но только на следующий символ.
И только если символ совпадает с очередным символом паттерна (а это можно пересчитывать на ходу).

Итог: можно посчитать префикс-функцию только для паттерна.

Реализация будет содержать небольшое дублирование кода вычисления префикс-функции.

[source,c]
----
int count_substrings_kmp(char *pattern, char *text) {
	int pattern_pi[MAX_PATTERN_SIZE] = {0};
	prefix_function(pattern, pattern_pi);
	int count = 0;
	int pi = 0;
	unsigned long pattern_len = strlen(pattern);
	for (int i = 0; text[i]; ++i) {
		while (pi > 0 && text[i] != pattern[pi]) {
			pi = pattern_pi[pi - 1];
		}
		if (text[i] == pattern[pi]) {
			pi++;
		}
		if (pi == pattern_len) {
			count++;
		}
	}
	return count;
}
----

===== Построение конечного автомата

По префикс функции очень удобно строить конечный автомат, распознающий строку.
Как и в случае КМП нам будет достаточно посчитать префикс-функцию только для паттерна.

Подробно не будем рассматривать, что такое конечный автомат (под это будет отдельная лекция).
Но коротко опишу, как он действует в данной задаче.

В предыдущем решении мы были вынуждены пересчитывать текущее значение префикс функции для каждого символа в тексте.

[source,c]
----
	while (pi > 0 && text[i] != pattern[pi]) {
		pi = pattern_pi[pi - 1];
	}
	if (text[i] == pattern[pi]) {
		pi++;
	}
----

Но можно для каждого допустимого символа сохранить информацию о том, как должна меняться префикс-функция при его появлении.
Такая табличка будет конечным автоматом.

Подробно алгоритм его построения по префикс-функции паттерна можно прочитать в статье про префикс-функцию.
Я же покажу очень элегантное решение на C, которое вообще не требует явного вычисления префикс-функции паттерна.
Исходное решение когда-то жило по ссылке https://algolist.manual.ru/search/esearch/aut.php (но, по-моему, она мертва).
В своё время я далеко не сразу въехал, почему оно работает, и будет очень круто, если разберётесь.

[source,c]
----
int count_substrings_dfa(char *pattern, char *text) {
	// Строим конечный автомат
	int p_size = strlen(pattern);
	int delta[MAX_PATTERN_SIZE][ALPHABET_SIZE] = {0};
	for (int q = 0; q < p_size; ++q) {
		int q_next = delta[q][pattern[q]];
		delta[q][pattern[q]]=q + 1;
		memcpy(delta[q + 1], delta[q_next], ALPHABET_SIZE * sizeof(int));
	}

	// Обрабатываем текст, используя построенный автомат
	int count = 0;
	int q = 0;
	for(char *t = text; *t; ++t) {
		q = delta[q][*t];
		if (q == p_size) {
			count++;
		}
	}
	return count;
}
----

Недостатком этого решения является потребление памяти (по сравнению с КМП), зато, зная текущее значение префикс функции и очередной символ, мгновенно по таблице получаем новое.

== Задача 9

Напишите программу, печатающую все простые числа, не превосходящие заданного числа.

=== Решения

Это очень известная и важная задача в математике и информатике.
Есть много известных алгоритмов, решающих её.

* https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes[Решето Эратосфена]
* https://en.wikipedia.org/wiki/Sieve_of_Atkin[Решето Аткина]
* и многие другие

Мы же пойдём от наивного алгоритма и будем по ходу дела его улучшать.

==== Наивный алгоритм

Давайте просто все числа от `2` до `n` проверять на простоту:

* Перебираем потенциальные делители от `2` до `n - 1`.
** Если проверяемое число делится на выбранный делитель, то оно не простое, переходим к следующему.
* Если ни один потенциальный делитель не подошёл, то это число простое, печатаем его.

Реализация на C будет очень простая.

[source,c]
----
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
	if (argc != 2) {
		printf("Illegal number of arguments\nUsage: %s <number>\n", argv[0]);
		return 1;
	}
	int n = atoi(argv[1]);
	printf("Primes: ");
	for (int i = 2; i <= n; ++i) {
		int is_prime = 1;
		for (int d = 2; d < i; ++d) {
			if (i % d == 0) {
				is_prime = 0;
				break;
			}
		}
		if (is_prime) {
			printf("%d, ", i);
		}
	}
	printf("\n");
	
	return 0;
}
----

==== Немного улучшим перебор

Давайте внесём сразу два улучшения

* Все чётные числа кроме `2` являются составными.
Давайте перебирать кандидаты в простые числа и кандидаты в их делители только среди нечётных.
* Нет смысла перебирать потенциальные делители, которые больше stem:[\sqrt{i}].
Если есть делитель больше stem:[\sqrt{i}], то мы уже проверили делитель меньше корня stem:[\sqrt{i}]
(все делители не могут быть больше stem:[\sqrt{i}], ведь в таком случае их произведение будет больше stem:[i]).

[source,c]
----
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int main(int argc, char *argv[]) {
	if (argc != 2) {
		printf("Illegal number of arguments\nUsage: %s <number>\n", argv[0]);
		return 1;
	}
	int n = atoi(argv[1]);
	printf("Primes: ");
	if (n >= 2) {
		printf("2, ");
	}
	for (int i = 3; i <= n; i += 2) {
		int is_prime = 1;
		for (int d = 3; d <= (int) sqrt(i); d += 2) {
			if (i % d == 0) {
				is_prime = 0;
				break;
			}
		}
		if (is_prime) {
			printf("%d, ", i);
		}
	}
	printf("\n");

	return 0;
}
----

[IMPORTANT]
====
При компиляции надо будет добавить ещё один флаг: `-lm`, который подключает к нашей программе математическую библиотеку.
Без этого флага программа не скомпилируется.
====

==== Ещё улучшим перебор делителей

В предыдущем решении мы перебирали все нечётные числа в кандидаты делителей.
Но проверяя stem:[i] на простоту мы уже знаем все простые числа, меньшие stem:[i].
Давайте проверять в качестве делителей только их.

Получаем достаточно эффективную реализацию.

[source,c]
----
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define MAX_PRIMES_COUNT 1000

int main(int argc, char *argv[]) {
	if (argc != 2) {
		printf("Illegal number of arguments\n");
		printf("Usage: %s <number>\n", argv[0]);
		return 1;
	}
	int n = atoi(argv[1]);
	printf("Primes: ");
	int primes[MAX_PRIMES_COUNT] = {0};
	int primes_count = 0;
	if (n >= 2) {
		primes_count = 1;
primes[0] = 2;
	}
	for (int i = 3; i < n; i += 2) {
		primes[primes_count++] = i;
		for (int j = 0; primes[j] <= (int) sqrt(i); ++j) {
			if (i % primes[j] == 0) {
				primes_count--;
				break;
			}
		}
	}
	for (int i = 0; i < primes_count; ++i) {
		printf("%d, ", primes[i]);
	}
	printf("\n");
	
	return 0;
}
----

== Задача 10

Напишите программу, считающую количество нулевых элементов в массиве.

=== Решение

Наверное, это самая простая задача на программирование (надеюсь, вы не испугались её простоты).

В целом ожидаемое решение было примерно таким.

[source,c]
----
int count_zeros(int *arr, int arr_size) {
	int zeros = 0;
	for (int i = 0; i < arr_size; ++i) {
		if (arr[i] == 0) {
			zeros++;
		}
	}
	return zeros;
}
----

[IMPORTANT]
====
Единственный важный момент заключается в том, что считать нулевым элементом.
Проблема вылезает даже с числами (но не целыми).
Для чисел с плавающей запятой типично накапливать ошибку при вычислениях.
Поэтому их не стоит сравнивать с помощью `==` (подробнее это обсудим на занятии про числа с плавающей запятой).

А для сложных типов данных этот ответ может быть ещё менее простым.
Например «нулевая строка» (можем же мы сделать массив строк) -- это `NULL` (отсутствие какого-либо значения) или `""` (пустая строка), или оба значения?

О таких вопросах тоже стои задумываться.
====
