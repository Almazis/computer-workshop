= Базовые конструкции языка Си
Anna Vasenina <almazisdev@gmail.com>
:page-toclevels: 4
:source-highlighter: rouge
:rouge-style: github
:icons: font

В нижеприведенных lecture notes содержится довольно много тонкостей и,
которыми не стоит пользоваться при программировании на языке Си. Когда
вы будете читать реальный код на Си, в том числе своих собственных
программ, то в них все будет намного легче и прямолинейнее. Вообще я за
то и люблю Си, что единственно правильный способ писать на нем это так,
чтобы программа делала ровно то, что написано, не больше и не меньше.
Тем не менее, материалы приводятся для ознакомительных целей: чтобы вы
знали, где можно допустить ошибки и при этом компилятор не настучит вам
по рукам. А также, чтобы при возникновений сложностей с чтением кода на
Си вы могли обратиться к этому материалу. Мне в свою бытность студентом
легко удалось пересесть с Python на Си, так сказать, без мам, пап и
[line-through]#кредитов# книжек. И у вас тоже получится, если просто не бояться программировать.

== Конструкции потока управления

=== Кодовый блок. Функция

[source,c]
----
int my_sum(int first, int second)
{
    return first + second;
}
----

* Сигнатура функции (1 строка) состоит из
** Типа возвращаемого значения (int — целое число)
** Имени функции
** Описание агрументов в формате `+тип имя+`
* Код, расположенный внутри фигурных скобок называют кодовым блоком
* Телом функции называется кодовый блок, следующий за сигнатурой функции
* Последовательности инструкций разделяются через `+;+`
* Если функция возвращает значение (тип возвращаемого значения не
`+void+`), то любой путь исполнения функции должен заканчиваться
`+return возвращаемое_значение;+`

=== Кодовый блок. Ветвление

[source,c]
----
#include <stdio.h>

void display_abs(int input_val)
{
    if (input_val < 0) {
        int tmp_value;
        tmp_value = -input_value;
        printf("displaying %d\n", tmp_value);
    } else {
        printf("displaying %d\n", input_value);
    }
}

int display_test(void)
{
    display(-3);
    display(8);
    return 0;
}
----

* Ветвление производится с помощью синтаксической конструкции
`+if (условие) { } else { }+`
* Кодового слова `+elif+` с языке Си нет. При необходимости
множественного ветвления используется конструкция
`+if (условие 1) { } else if (условие 2) { } else { }+`
* Объявление переменных строится по схеме `+тип имя_переменной+`,
например `+int tmp_val+` это переменная типа int (integer,
целочисленное) с именем tmp_val
* Переменная, объявленная в кодовом блоке называется локальной, область
ее видимости ограничивается её кодовым блоком
* Один из способов вывода значения на печать является функция printf.
Для возможности её использования необходимо подключить заголовочный файл
с её оъявлением из стандартной библитеки Си. Для подключения
используется конструкция `+#include <имя_заголовочного_файла>+`. Принято
"`инклюды`" ставить в начало файла, хотя компилятор не запрещает делать
этого в середине файла (но вне функции)
* Первым аргументом функции является строка, содержащая текст, который
будет выведен в поток стандартного ввода-вывода (stdout). Опционально,
строка может содержать встроенные метки форматирования, начинающиеся с
символа `+%+`. Эти метки заменяются значениями, указанными в последующих
дополнительных аргументах. Метки форматирования обязаны указывать тип
выводимого значения, опционально к веткам можно добавлять ограничения на
ширину поля, точность и другие дополнительные параметры
* Для вывода типа int метка форматирования, содержащая только тип
выводимого значения выглядит следующим образом: `+%d+`
* Вывод на печать стоит заканчивать символом перевода строки (для Linux:
`+\n+`). В случае, если символ перевода строки отсутствует в выводе, то
вы можете не увидеть вывода
* Функции, не принимающие аргументов вместо списка аргументов содержат
ключевое слово `+void+`

=== Кодовый блок. Цикл

[source,c]
----
for (int i = 0; i < 3; i += 1) {
    do_something
}
----

* Конструкция цикла for состоит из трех частей, разделенных оператором
`+;+`
** Присвоение значения (делается один раз в начале цикла)
** Условие, проверяющееся каждый раз перед началом выполнения телацикла
** Модификация — действие в конце тела цикла
* Любой из блоков может отсутствовать. При отсутствии блока условия оно
воспринимается как константная истина:

[source,c]
----
for (;;) {
    infinite_loop_action();
}
----

* В теле цикла МОЖЕТ выполнятся присваивание любых видимых значений, в
том числе тех, что модифицируются в блоке модификации и проверяются в
блоке условия. Таким образом, строго говоря, цикл for не является циклом
с фиксированным количеством повторений. Тем не менее такое поведение
контринтуитивно и делает код менее читаемым, поэтому, если вам оно
требуется, то рекомендуется использовать цикл с предусловием (цикл
while)
* На самом деле цикл for это "`синтаксический сахар`" над циклом while
(= цикл for переписывается в цикл while)

[source,c]
----
int i = 0;
while(i < 3) {
    do_something();
    i++;
}
----

[source,c]
----
while (true) {
    infinite_loop_action();
}
----

=== Кодовый блок. Цикл с постусловием

[source,c]
----
int i = 0;
do {
    do_something();
    i++;
} while(i < 3)
----

[source,c]
----
int i = 8;
do {
    do_something(); // будет выполнено
    i++; /* инкрементируем счетчик */
} while(i < 3)
----

* Комментарии к коду пишутся как `+// однострочный комментарий+` или
`+/* многострочный комментарий */+`
* Тело цикла с постусловием всегда будет выполнено хоть один раз. Даже
если в условии стоит false
* Это часто используется в многострочных макросах (о них будет далее)
для выделения макроса в отдельный кодовый блок и защиты от перекрывания
значений переменных
* Оператор `++` это оператор унарного
инкремента, увеличивающий значение переменной на 1. Он может стоять до имени переменной или после. Отличаются эти случаи возвращаемым значением. Лично я не рекомендую пользоваться
возвращаемым значением унарного инкремента в принципе. Эффективность
кода вы скорее всего не улучшите, но можете существенно понизить читаемость

[source,c]
----
int i = 0, j = 0;
int pre_incr = ++i;
int post_incr = j++;

printf("i %d, j %d, pre_incr %d post_incr %d\n",
       i, j, pre_incr, post_incr);
       /* 1 1 1 0 */
----

* Если нужно проинициализировать несколько значений одного типа, то это
можно делать через запятую
`+тип имя_переменной1 = значение1, имя_переменной2 = значение2+`

=== Кодовый блок. Вложенные блоки

[source,c]
----
int main() {
    int outer = 233;
    {
        int inner = 5;
        printf("outer=%d, inner=%d\n", outer, inner);
    }
    // ошибка компиляции:
    printf("outer=%d, inner=%d\n", outer, inner);

    return 0;
}
----

* Исполнение программы начинается с функции с именем main
* Сигнатура функции main, когда нам не нужно принимать значения от
пользователя следующая.
** int main(void) ~ int main()
* Кодовый блок может содержать внутри себя другие (вложенные) кодовые
блоки. В этом случае переменные, объявленные во внешнем блоке будут
видны и во вложенном блоке. Переменные, объявленные во вложенном блоке,
не будут видны во внешнем блоке

[source,c]
----
int main() {
    int outer = 233;
    {
        int outer = 5;
        printf("outer=%d\n", outer); /* 5 */
    }

    printf("outer=%d\n", outer); /* 233 */

    return 0;
}
----

* В случае, если во вложенном кодовом блоке объявлена переменная с
именем, совпадающим с переменной из внешнего кодового блока, то внешняя
переменная будет "`перекрыта`" до конца вложенного кодового блока

== Типы данных

=== Базовые типы данных

* Базовыми типами данных называются типы данных из фиксированного списка
** Целочисленные
*** (unsigned/signed)char
*** (unsigned/signed)short
*** (unsigned/signed)int
*** (unsigned/signed)long
*** (unsigned/signed)long long
** С плавающей точкой
*** float
*** double
*** long double

=== Структуры

[source,c]
----
struct xy_point {
    int x;
    int y;
}

struct xyz_point {
    struct xy_point xy;
    int z;
}

int main() {
    struct xy_point point_2d = {.x = 1, .y = 5};
    struct xy_point another_point_2d = {4, -3};
    struct xyz_point point_3d;

    point_3d.xy = point_one;
    point_3d.z = 8;

    printf("\n", point_3d.xy.x, point_3d.xy.y, point_3d.z);
}
----

* Структура это набор хранящихся и использующих совместно данных.
Структура состоит из полей, поле может именть базовый тип (напр.
`+int+`), тип структуры (`+struct xy_point+`) или тип указателя (о них
далее). У каждого поля, к которому можно обращаться, есть имя, по
которому происходит обращение
* Представители структур объявляются с использованием ключевого слова
`+struct имя_типа_структуры имя_представителя+`
* Доступ к полям структуры осуществляется через
`+имя_представителя.имя_поля+`
* Значения полей структуры можно задавать при объявлении с помощью
перечисления полей в фигурных скобках, либо с помощью операции
присваивания (`+=+`), как и переменным
* Данный пример скорее демонстрационный. Не всегда стоит пользоваться
вложенными структурами, если у вас уже есть похожая структура. По сути
это имеет смысл только, когда у вас есть функциональность для вложенной
структуры, которую вы хотите переиспользовать и для бОльшей структуры

=== Указатели

[source,c]
----
int val = 34;
int* pointer_to_val = &val;
int val_from_pointer = *pointer_to_val;

printf("val %d, ponter_to_val %p, val_from_ponter %d\n",
       val, pointer_to_val, val_from_pointer);
----

* Тип указателя формируется как `+тип_значения *+` или
`+тип_значения*+`. В примере кода выше используется второе обозначения
для более явного различия между типами. Однако, по большинству стилей
кодирования правильным является придерживаться первого обозначения, что
я буду делать в дальнейшем
* Чтобы получить из значения указалель на это значение применяется
унарная операция `+&+`, называемая операцией взятия адреса
* Чтобы получить значение по указателю используется унарная операция
`+*+`, называемая разыменованием указателя
* Для вывода значения указателя на печать используется метка
форматирования `+%p+`

image::img/pointer.png[]

* По сути указатель это просто числовое значение, которое трактуется как
место в памяти
* Обычно значение указателя записывается в 16-ричном формате. То, что
число записано в шестнадцатиричном формате указывается с помощью
прификса `+0x+`

== Использование указателей

=== Указатель как аргумент функции

[source,c]
----
void value_incrementer(int in_value)
{
    in_value += 1;
}

void pointer_incrementer(int *in_value)
{
    *in_value += 1;
}

int main() {
    int val = 34;
    int *pointer_to_val = &val;

    value_incrementer(val);
    printf("val %d\n", val);

    pointer_incrementer(pointer_to_val);
    printf("val %d\n", val);

    return 0;
}
----

* Указатель надо передавать как аргумент функции в двух случаях.
** Когда нужно изменить значение внутри функции
** Когда нужно передать большую структуру, которую неэффективно
копировать

=== Указатель на структуры

[source, c]
----
void point_initializer(struct xy_point *p) {
    p->x = 0;
    p->y = 0;
}

void point_printer(struct xy_point *p) {
    printf("`(%d, %d)`", p->x, p->y);
}
----

- Синтаксис `+->+` позволяет получить доступ к полю структуры, если структура задана указателем. По факту позволяет разыменовать конкретное поле, при этом полное разыменование указателя на структуру не происходит

=== NULL-pointer

[source, c]
----
int *ptr = NULL;
printf("%d\n",*ptr);

----

* NULL-pointer это _специальный_ указатель, который не указывает на
какой-либо адрес в памяти. Он используется для обозначения отсутствия
ссылки на объект
* Разыменование NULL-pointer приведет к ошибке времени исполнения
* Часто используется для инициализации указателя перед его первым
использованием во избежание сокрытия ошибок при случайном использовании
неинициализированных указателей

=== Мусорные указатели

[source,c]
----
int *ptr;
printf("%d\n", *ptr);
----

* Мусорный указатель (висячий указатель, dangling pointer) —
это указатель, который ссылается на область памяти, которая уже
была освобождена или на область, которая никогда не была
корректно инициализирована
* Использование такого указателя может привести к непредсказуемому
поведению программы, примерами такого поведения могут быть:
** Аварийное завершение программы
** Повреждение данных
** Порча других указателей
* Мусорный указатель гораздо страшнее, чем NULL-pointer так как
последствия его использования могут вылезти совершенно в случайном меяте
программы и это очень плохо поддается отладке, особенно в больших
проектах

=== Возврат указателя из функции

==== Указатель на значение "`на стеке`"

[source,c]
----
struct xy_point *create_point_faulty(void)
{
    struct xy_point p;

    p.x = 0;
    p.y = 0;
    return &p; /* ТАК НЕЛЬЗЯ */
}
----

* При определении значения внутри кодового блока, время жизни этого
значения будет ограничено временем выполнения кодового блока, поэтому
при возврате указателя он становится мусорным
* Определение значения таким образом называется определением "`на
стеке`". На будущих занятиях, мы подробнее познакомимся с этим понятием,
сейчас же нам достаточно знать, что объект, на который мы возвращаем
указатель в функции выше, перестанет существовать, а значит,
использовать указатель нельзя

==== Указатель на значение "`на куче`"

[source,c]
----
#include <stdlib.h>

struct xy_point *create_point_better(void)
{
    struct xy_point *p;

    p = malloc(sizeof(*p));
    p->x = 0;
    p->y = 0;
    return p;
}
----

* Функция malloc позволяет выделить память, время жизни которой больше,
чем кодовый блок, в котором произошло выделение. Такое выделение
называется выделением памяти на куче. Память, выделенная с помощью
malloc будет зарезервирована для использования до конца исполнения
программы либо до ее освобождения с использованием функции free
* Такое выделение памяти называют динамическим, так как до выполнения
вызова функции неизвестно, где именно будет расположена выделенная
память, функцию, выделяющую память называют *аллокатором*
* Для использования malloc необходимо подключить заголовочный файл с её
оъявлением из стандартной библитеки Си, файл stdlib.h
* Аргументом malloc передается количество памяти в байтах. Для того,
чтобы избавиться от необходимости редактировать весь код при добавлении
поля в структуру, можно использовать оператор sizeof, который вернет
количество байт, необходимое для размещения значения заданного типа.
Аргуметном sizeof может быть как имя типа
`+sizeof(int), sizeof(struct xy_point)+`, так и конкретный экземпляр
определенного типа, при этом из экземпляра будет взят только его тип, то
есть разыменование мусорного или нулевого указателя конкретно в качестве
аргумента sizeof допустимо
* Также возможны алтернативные варианты:
** malloc(sizeof(struct xy_point))
** malloc(2*sizeof(int))
** malloc(4096); // можно аллоцировать больше, чем занимает структура,
но этим стоит грамотно пользоваться
* Также аллокация памяти может проводится с использованием фукции
`+calloc+`, выделенная память в этом случае будет инициализирована
нулями
* Далее в курсе вы познакомитесь с внутренним устройством стандартного
аллокатора и альтернативными реализациями

==== Ошибки при использовании памяти "`на куче`"

[source,c]
----
struct xy_point *create_point_correct(void) {
    struct xy_point *p = NULL;

    p = malloc(sizeof(*p));
    if (!p) {
        fprintf(stderr, "Could not allocate memory\n");
        return NULL;
    }
    p->x = 0;
    p->y = 0;
    return p;
}

void main() {
    struct xy_point *p = create_point_correct();

    some_action_with_point(p);
    free(p);
    return 0;
}
----

* Стоит присваивать указатель в NULL, чтобы избедать ошибок
использования мусорных указателей
* Функция аллокации может провалиться, например, если нет доступной
памяти. В случае ошибки malloc вернёт NULL-pointer. Для того, чтобы
избежать ошибки разыменования, необходимо проверять возврат функции:
условие (`+if (!p)+`) будет истино, если функция malloc вернула
NULL-pointer.
* В случае ошибки malloc, чтобы не переходить к разыменованию указателя
(с помощью `+->+`), печатается сообщение в стандартный поток вывода
ошибок (stderr), с помощью функции вывода в файл (fptintf), а затем
возвращается NULL-pointer
* Общая рекомендация по написанию кода — написали malloc, сразу пишите
free (там где это предполагается логикой программы), так как время жизни
программы может быть долгим и без освобождения памяти вы рискуете уйти в
нехватку оперативной памяти, такая ситуация называется *утечкой памяти*

== Массивы

image::img/arr.png[]

* Массивом называется коллекция содержащая фиксированное количество
элементов одинакового типа, расположенных последовательно в памяти
* За счет последовательного расположения элементов можно за одну
операцию получить элемент по индексу, зная адрес первого элемента

=== На стеке

[source,c]
----
int arr_calc_len[] = {8, 3, -9}; // длина 3
int arr_fix_len[5] = {8, 3, -9}; // длина 5, оставшиеся значения --- нули
int zero_arr[6] = {}; // все значения нули
int arr_uninit[7]; // все значения неинициализированы
int arr_len;

arr_len = sizeof(arr_calc_len) / sizeof(arr_calc_len[0]);
for (int i = 0; i < arr_len; i++)
    printf("arr_calc_len[%d] = %d\n", i, arr_calc_len[i]);

arr_len = sizeof(arr_fix_len) / sizeof(arr_fix_len[0]);
for (int i = 0; i < arr_len; i++)
    printf("arr_fix_len[%d] = %d\n" i, arr_fix_len[i]);
----

* Массив объявляется конструкцией
`+тип_элемента имя_массива[длина_массива] = {перечисление элементов}+`
* Если пропустить указание длины массива, то она будет вычислена из как
количество элементов, указанных в перечислении элементов
* Если указать длину массива и в перечислении указать меньше элементов,
то оставшиеся значения будут считаться нулями
* Часто встречается конcтрукция `+= { }+`, инициализирующая все элементы
массива нулями. В этом случае обязательно указывать длину массива
* Если оставить массив неинициализированным (`+arr_uninit+`), то все его
элементы будут неинициализированы (могут принимать случайное значение)
* Конструкция `+sizeof(array)+` вернет количество байт, которое занимает
массив, поэтому чтобы вычислить количество эллементов в массиве нужно
длину массива в байтах разделить на длину одного элемента в байтах
* Доступ к элементу массива осуществляется с помощью конструкции
`+имя_массива[номер_элемента]+`

[source,c]
----
void fill_arr_error() {
    int arr[5];
    arr = {1, 2, 3, 4, 5}; // Ошибка компиляции
}

void fill_arr_correct() {
    int arr[5];
    int arr_len = sizeof(arr) / sizeof(arr[0]);

    for (int i = 0; i < arr_len; i++)
        arr[i] = i;
}
----

* Конструкцию `+arr = {...}+` можно использовать только в момент
инициализации массива, использование ее после вызовет ошибку времени
компиляции. Если вам нужно заполнить массив после инициализации, то
пользуйтесть доступом к элемента по индексу

=== На куче

[source,c]
----
int arr_len = 1024;
int *arr = malloc(sizeof(int) * arr_len);

printf("sizeof(arr) = %llu, sizeof(int), sizeof(int *)\n",
       sizeof(arr), sizeof(int), sizeof(int *));

for (int i = 0; i < arr_len; i++)
    arr[i] = i;

free(arr);
----

* Для создания больших массивов нельзя использовать стек, но можно
выделить массив на куче, используя аллокатор памяти
* Доступ к элементу массива `+arr[i]+` при этом является
"`синтаксическим сахаром`" над операциями ариметики указателей
`+arr[i] ~ *(arr + i)+`. Приведенная запись обозначает, что мы сначала
двигаем указатель на i элементов дальше, а затем разыменовываем эту
область памяти. Размер элемента при этом определяется по типу указателя
В дальнейшем мы подробнее рассмотрим механизмы арифметики указателей.
* Размер `+arr+` при этом будет равер размеру типа указателя (`+int *+`)
* Не забывайте освобождать выделенную память с помощью функции `+free+`

=== Выход за границы массива

[source,c]
----
int arr[3] = {};

// Компилируется успешно, может привести к ошибке времени исполнения
for (int i = 0; i < 8; i++)
    printf("arr[%d] = %d\n", i, arr[i]);
----

* Ни один способ определения массива не защищает вас от доступа за
пределы массива. Это одна из основных проблем новичков

== Строки

image::img/string.png[]

[source,c]
----
char s_arr_long[] = {'E', 'x', 'a', 'm', 'p', 'l', 'e', '\n', '\0'};
char s_arr_short[] = "Example\n";
char *s_malloc = malloc(sizeof(char) * 4);
char *s_static = "Example2\n";

printf("%s", s_arr_long);
s_arr_long[0] = 'e';
printf("%s", s_arr_long);

printf("%s", s_arr_short);
s_arr_short[0] = 'e';
printf("%s", s_arr_short);

strcpy(s_malloc, "abc");
strcpy(s_malloc, "abcd"); // Так нельзя, не хватит места на \0

// Ошибка времени исполнения
s_static[0] = 'e';
----

* Стандартная для языка Си строка придставляет собой массив значений
целочисленного типа char
* sizeof(char) *чаще всего* равен 1, этого достаточно чтобы вместить 256
символов, кодируемых по таблице ASCII
* Символ окончания строки `+\0+`, имеет числовое значение 0. Не путать с
символом перевода строки. Если вы задаете строку с помощью синтаксиса
двойных кавычек, то этот символ автоматически добавляется в конец
строки. При задании строки синтаксисом массивов, а также, что гораздо
важнее, при выделении памяти и выполнении операций со строками, важно
помнить о символе '`\0`'
* Строки, заданные с помощью синтаксиса `+char *s = "text"+` являются
неизменяемыми

=== Стандартные функции работы со строками

В основном объявлены в <string.h>. Примеры:

* strlen(char *s)

[source,c]
----
for (int i = 0; true; i++)
    if (s[i] == '\0')
        return i;
----

* strcpy(char *dest,  char *src)

[source,c]
----
for (int i = 0; true; i++) {
    dest[i] = src[i]
    if (dest[i] = '\0')
        return;
}
----

* strncpy(char *dest, char *src, int n)

[source,c]
----
for (int i = 0; i < n; i++) {
    dest[i] = src[i]
    if (dest[i] = '\0')
        return;
}
----

=== Массив строк

image::img/string_arr.png[]

[source,c]
----
char **str_arr = malloc(sizeof(char *) * count);
for (int i = 0; i < count; i++) {
    str_arr[i] = malloc(sizeof(char) * max_str_len);
}
----

* Массив строк это массив массивов типа `+char+`, поэтому для его
выделения сначала аллоцируем массив с типом хранимого значения
`+char *+`, затем каждый элемент инициализируется выделением памяти под
хранение строк

=== Передача аргументов в функцию main (argc, argv)

[source,c]
----
int main(int argc, char **argv) {
    for (int i = 0; i < argc; i++)
        printf(argv[i]);
}
----

* argc — количество переданных аргументов (длина массива argv)
* argv — массив строк, содержащий переданные аргументы

=== Передача аргументов в программу (scanf)

[source,c]
----
int input_val = 0;

printf("Value before input: %d\n", input_val);
printf("Insert integer value:\n");
scanf("%d", &input_val);
printf("Value after input: %d\n", input_val);
----
